---
title: "Rapport"
author: "Alban Souchard, Paul Fernandez, Thomas Matamba, Klimentiy Mirek"
date: "2025-04-23"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

plotnum <- 0
knit_print.ggplot <- function(x, options) {
  plotnum <<- plotnum + 1
  ggsave(sprintf("graphics/graph-%02d.png", plotnum), x +
  theme(
    panel.background = element_rect(fill='transparent'),
    plot.background = element_rect(fill='transparent', color=NA),
    legend.background = element_rect(fill='transparent', colour='transparent', linetype = 'blank'),
    legend.box.background = element_rect(fill='transparent', colour='transparent', linetype = 'blank')
  ), bg='transparent')
  print(x)
}
knit_print.plotly <- function(x, options, ...) {
  plotnum <<- plotnum + 1
  orca(x %>% layout(
    plot_bgcolor = "rgba(0,0,0,0)",
    paper_bgcolor = "rgba(0,0,0,0)"
  ), sprintf("graphics/graph-%02d.png", plotnum), scale = 10)
  if (!is.null(options$fig.width)) x$width <- options$fig.width * 96
  if (!is.null(options$fig.height)) x$height <- options$fig.height * 96
  htmlwidgets:::knit_print.htmlwidget(x, options, ...)
}
```

# IF36 \- Proposition

## Introduction

Dans le cadre du projet pour l’UE IF36, “Visualiser des données”, notre groupe utilisera le jeu de données suivant : “Spotify and Youtube, Statistics for the Top 10 songs of various spotify artists and their yt video”. Ce dataset provient du site kaggle.com, et est fait par Salvatore Rastelli, Marco Sallustio et Marco Guarisco. Le dataset a été publié le 7 février 2023, avec les données provenant de 2 sources : Spotify, Youtube.

Ce jeu de données est composé de 20 717 individus, avec 28 features. Le tableau suivant contient chaque feature, type et son description : 

| *Feature*  | *Type* | *Description* |
| :-- | :-- | :------ |
| \# | entier | id |
| `Track` | string | Nom de la chanson tel qu'affiché sur Spotify. |
| `Artist` | string | Nom de l'artiste. |
| `Url_spotify` | string | Lien URL vers le profil Spotify de l'artiste. |
| `Album` | string | Album Spotify contenant la chanson. |
| `Album_type` | catégorielle | Indique si la chanson est sortie en tant que single, un album, ou autre. |
| `Uri` | string | Lien Spotify utilisé pour identifier précisément la chanson via l’API Spotify. |
| `Danceability` | float | Score (0 à 1\) indiquant à quel point la chanson est adaptée à la danse (0 \= peu adaptée, 1 \= très adaptée). |
| `Energy` | float | Mesure (0 à 1\) de l'intensité et de l'activité du morceau. Plus la valeur est élevée, plus le morceau est énergique et dynamique. |
| `Key` | catégorielle | Tonalité de la chanson représentée par un chiffre (0 \= Do, 1 \= Do/Ré, 2 \= Ré, etc.). Une valeur de \-1 indique une tonalité non détectée. |
| `Loudness` | float | Volume moyen de la chanson en décibels (dB), généralement entre \-60 et 0 dB. |
| `Speechiness` | float | Indique (0 à 1\) la présence de paroles parlées (0 \= essentiellement musicale, \>0.66 \= essentiellement parlée, entre 0.33 et 0.66 \= mixte). |
| `Acousticness` | float | Probabilité (0 à 1\) que le morceau soit acoustique (1 \= forte certitude d’un morceau acoustique). |
| `Instrumentalness` | float | Probabilité (0 à 1\) que le morceau soit instrumental (sans voix). Plus la valeur est élevée, plus la chanson est probablement instrumentale. |
| `Liveness` | float | Probabilité (0 à 1\) que le morceau ait été enregistré en direct (live). Valeurs \> 0.8 indiquent probablement une performance live. |
| `Valence` | float | Score (0 à 1\) représentant l’émotion positive transmise par la chanson (0 \= négatif/triste, 1 \= positif/joyeux). |
| `Tempo` | float | Tempo moyen de la chanson en battements par minute (BPM). |
| `Duration_ms` | float | Durée totale du morceau en millisecondes. |
| `Stream` | entier | Nombre total d’écoutes de la chanson sur Spotify. |
| `Url_youtube` | string | Lien vers la vidéo de la chanson sur YouTube, si disponible. |
| `Title` | string | Titre de la vidéo YouTube associée. |
| `Channel` | string | Nom de la chaîne YouTube qui a publié la vidéo. |
| `Views` | entier | Nombre de vues sur YouTube. |
| `Likes` | entier | Nombre de "J’aime" sur YouTube. |
| `Comments` | entier | Nombre de commentaires sur la vidéo YouTube. |
| `Description` | string | Description de la vidéo sur YouTube. |
| `Licensed` | catégorielle | Indique si la vidéo contient du contenu sous licence officielle revendiquée par un partenaire YouTube. |
| `official_video` | catégorielle | Valeur booléenne (Vrai/Faux) indiquant si la vidéo YouTube est la vidéo officielle de la chanson. |

Le dataset utilisé est complet et ne devrait pas nécessiter de traitement de données particulier avant son utilisation. Cependant, pour l’analyse de données dans le cadre de notre projet, certaines features ne sont pas nécessaires, notamment : 

* `Url_spotify`
* `Uri`  
* `Url_youtube`  
* `Description`

## Chargement des Librairies utilisées
```{r libraries, message=FALSE, warning=FALSE}
library(ggplot2)
library(scales)
library(readr)
library(dplyr)
library(magrittr)
library(tidyr)
library(boot)
library(forcats)
library(fmsb)

## Define theme colors to use for graphs
theme <- "#63a0e1"
darktheme <- "#2e7bcf"
```

## Chargement du dataset
```{r dataset, message=FALSE, warning=FALSE}
dataset <- read_csv("data/Spotify_Youtube.csv")
```

## Analyse detaillée du dataset

### Question 1 : Quelle est la repartition des types d'album dans le dataset ? 
L'objectif est de visualiser la fréquence des chansons issues d'albums par rapport aux singles.


**Hypothèses**

**Traitement des données**

Ici, nous allons voir si dans la colonne Album_type nous avons des doublons ou des fautes de frappe ("Single" ou "sInGle")
```{r message=FALSE, warning=FALSE}
unique(dataset$Album_type)
```

**Visualisation**

Dans 

Affichage du graphique 1
```{r message=FALSE, warning=FALSE}
ggplot(dataset, aes(y = Album_type, fill = Album_type)) +
  geom_histogram(stat = "count")
```
**Observations diverses**

### Question 2 : Y a-t-il une corrélation entre la “danceability” et le tempo ?

**Hypothèse **

La *danceability* est un score qui indique à quel point une chanson est adaptée à la danse. Il est donc logique de penser qu'il existe une certaine corrélation entre le tempo et la *danceability*. En effet, un morceau avec un tempo rapide pourrait être plus dansant qu'un morceau avec un tempo lent.

**Traitement **

Pour réaliser cela nous allons utiliser un scatter plot ainsi qu'une courbe de tendance pour permettre d'identifier plus facilement si une tendance existe.
Nous allons également supprimer les valeurs anormales, c'est-à-dire les morceaux avec un tempo inférieur à 20 BPM ou supérieur à 250 BPM. En effet, ces morceaux sont très rares et pourraient fausser notre analyse.


```{r message=FALSE, warning=FALSE}
dataset %>%
  filter((Tempo > 20 & Tempo < 250)) %>%
  ggplot(aes(x = Tempo, y = Danceability)) +
  geom_hex(bins = 50) +
  scale_fill_viridis_c() +
  geom_smooth(method = "gam", se = FALSE, size = 1.5, color = "#FDE725") +
  labs(title = "Corrélation entre le tempo et la danceability", x = "Tempo (BPM)", y = "Danceability") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    panel.grid.major = element_line(color = "gray80"),
    panel.grid.minor = element_blank(),
  )
```

**Observations **

D'après le graphique, on constate qu'il y a une légère corrélation entre le tempo et la *danceability*. En effet, plus le tempo est élevé, plus la *danceability* augmente, jusqu'à un certain point. Au-delà de 120 BPM, la *danceability* semble se stabiliser voir même diminuer. Cela peut s'expliquer par le fait que les morceaux très rapides peuvent devenir trop complexes pour être dansés facilement. Ou encore que l'ensemble des données est très concentré vers les 100 BPM, ce qui fausse la perception de la tendance.

```{r message=FALSE, warning=FALSE}
# affichage de la repartition du tempo
dataset %>% ggplot(aes(x = Tempo)) +
  geom_histogram(binwidth = 5, fill = "steelblue", color = "black", alpha = 0.7) +
  labs(title = "Répartition du tempo", x = "Tempo (BPM)", y = "Nombre de morceaux") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12)
  )
```

En effet on remarque que la forme est similaire à une gaussienne, avec un maximum vers 100 BPM. Cela peut expliquer la tendance observée précédemment. Il n'y aurait donc pas ou très peu de corrélation entre le tempo et la *danceability*.

***
### Question 3 : Quelle est la distribution des émotions (valence) des chansons ?

**Hypothèse :**

On souhaite savoir si les morceaux sont globalement joyeux ou tristes. On peut imaginer que certains types de musique sont plus présents sur une plateforme que sur l'autre, par exemple plus de musiques joyeuses sur Youtube et plus de musiques tristes sur Spotify.

**Traitement des données**

On filtre les valeurs de valence pour que la valence soit toujours comprise entre 0 et 1 et on sépare les musiques selon si elles sont présentes sur Spotify ou Youtube.

```{r message=FALSE, warning=FALSE}
spotify_dataset <- dataset %>%
  filter(Valence >= 0 & Valence <= 1 & !is.na(Stream)) %>%
  select(Valence) %>%
  na.omit()
youtube_dataset <- dataset %>%
  filter(Valence >= 0 & Valence <= 1 & !is.na(Views)) %>%
  select(Valence) %>%
  na.omit()
```

**Visualisations :**

```{r message=FALSE, warning=FALSE}
# Création de l'histogramme avec courbe de densité
spotify_dataset %>% ggplot(aes(x = Valence)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = theme, color = "white", alpha = 0.7) +
  geom_density(color = darktheme, size = 1) +
  labs(
    title = "Distribution des émotions (valence) des chansons sur Spotify",
    x = "Valence (0 = triste, 1 = joyeux)",
    y = "Densité"
  ) +
  theme_minimal()
youtube_dataset %>% ggplot(aes(x = Valence)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = theme, color = "white", alpha = 0.7) +
  geom_density(color = darktheme, size = 1) +
  labs(
    title = "Distribution des émotions (valence) des chansons sur Youtube",
    x = "Valence (0 = triste, 1 = joyeux)",
    y = "Densité"
  ) +
  theme_minimal()
```

Les résultats de ces premiers graphiques montrent que les musiques présentes sur les deux plateformes sont plus joyeuses que tristes. Cela dit, il pourrait être intéressant de connaitre :

- le pourcentage de musiques plutôt joyeuse ($Valence > 0,5$)
- la valence moyenne des musiques du dataset
- la répartition de la valence des musiques présentes exclusivement sur l'une des deux plateformes (puisqu'on a $19673$ musiques qui sont communes aux deux plateformes)

**Déterminons le pourcentage de musiques plutôt joyeuses dans le dataset** 

```{r message=FALSE, warning=FALSE}
dataset %>%
  filter(Valence > 0.5) %>%
  nrow() / dataset %>% nrow()
```

Les musiques sont donc de manière générale plus joyeuses que tristes dans notre dataset.

**Déterminons la valence moyenne des musiques**

```{r message=FALSE, warning=FALSE}
dataset$Valence %>% mean(na.rm = TRUE)
```

**Trouvons la répartition de la valence des musiques présentes uniquement sur l'une des deux platformes**

```{r message=FALSE, warning=FALSE}
spotify_only_dataset <- dataset %>%
  filter(Valence >= 0 & Valence <= 1 & is.na(Views)) %>%
  select(Valence) %>%
  na.omit()
youtube_only_dataset <- dataset %>%
  filter(Valence >= 0 & Valence <= 1 & is.na(Stream)) %>%
  select(Valence) %>%
  na.omit()
spotify_only_dataset %>% ggplot(aes(x = Valence)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = theme, color = "white", alpha = 0.7) +
  geom_density(color = darktheme, size = 1) +
  labs(
    title = "Distribution de la valence des chansons présentes exclusivement sur Spotify",
    x = "Valence (0 = triste, 1 = joyeux)",
    y = "Densité"
  ) +
  theme_minimal()
youtube_only_dataset %>% ggplot(aes(x = Valence)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = theme, color = "white", alpha = 0.7) +
  geom_density(color = darktheme, size = 1) +
  labs(
    title = "Distribution de la valence des chansons présentes exclusivement sur Youtube",
    x = "Valence (0 = triste, 1 = joyeux)",
    y = "Densité"
  ) +
  theme_minimal()
```

Pour rappel, ces graphiques se basent sur peu de données, à savoir sur $469$ valeurs pour Spotify et $576$ valeurs pour Youtube.

```{r message=FALSE, warning=FALSE}
nrow(spotify_only_dataset)
nrow(youtube_only_dataset)
```

Il apparait cependant que les musiques présentes uniquement sur Spotify ont tendance à avoir une valence répartie autour de $0,7$ : ce sont donc des musiques relativement joyeuses; là où les musiques présentes exclusivement sur Youtube ont une valence mieux répartie, incluant ainsi plus de musiques plus joyeuses et plus de musiques plus tristes que sur Spotify.

***
### Question 4 : Les chansons live ont-elles tendance à avoir plus de vue sur Youtube que Spotify ?

**Hypothèse **

On peut imaginer que les chansons live sont plus populaires sur Youtube que sur Spotify, car Youtube est une plateforme de vidéo et de contenu visuel. De plus, les concerts et les performances live sont souvent partagés sur Youtube, ce qui pourrait expliquer une tendance à avoir plus de vues sur cette plateforme.

**Traitement des données **

Nous allons créer deux boxplot pour comparer le nombre de vues sur Youtube et Spotify pour les chansons live et non-live (studio).
Nous allons également créer une nouvelle variable pour différencier les morceaux live et studio à l'aide de la feature *Liveness*. En effet, cette feature indique si le morceau a été enregistré en live ou non. Nous allons donc créer une nouvelle variable *is_live* qui prendra la valeur "Live" si la valeur de *Liveness* est supérieure à 0.8, et "Studio" sinon.
L'affichage des boxplots se fera suivant une échelle logarithmique, afin de mieux visualiser les différences entre les deux plateformes.

```{r message=FALSE, warning=FALSE}
# Afficher le nombre de musiques live
live_music <- dataset %>%
  filter(Liveness > 0.8) %>%
  select(contains("Stream"), contains("Views"))
print(paste("Nombre de musiques live :", nrow(live_music)))
```

Nous remarquons que le nombre de musique live n'est que de 385, soit environ 2% du dataset. Les résultats pourraient donc être biaisés par le faible nombre de musiques live.

**Visualisations :**

``` {r message=FALSE, warning=FALSE}
# Crée une variable pour différencier les morceaux live et studio
live_dataset <- dataset %>%
  filter(!is.na(Liveness)) %>%
  mutate(is_live = ifelse(Liveness > 0.8, "Live", "Studio"))

# Crée une fonction pour créer les boxplots
plot_boxplot <- function(data, xvar, yvar,xlab, ylab, title, subtitle) {
  ggplot(data, aes_string(x = xvar, y = yvar, fill = xvar)) +
    geom_boxplot(outlier.shape = NA, size = 0.7) +
    scale_y_log10(labels = scales::comma) +
    labs(
      title = title,
      subtitle = subtitle,
      x = xlab,
      y = ylab,
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 18, hjust = 0.5, face = "bold"),
      plot.subtitle = element_text(size = 13, hjust = 0.5),
      axis.title = element_text(size = 14),
      axis.text = element_text(size = 12),
    ) +
    guides(fill = "none")
}

# Appel de la fonction pour créer les boxplots
plot_streams <- plot_boxplot(
  live_dataset, "is_live", "Stream", "Type de chanson", "Nombre d'écoutes (log)",
  "Comparaison des écoutes Spotify", "Entre chansons Live et Studio"
)

plot_views <- plot_boxplot(
  live_dataset, "is_live", "Views", "Type de chanson", "Nombre de vues (log)",
  "Comparaison des vues YouTube", "Entre chansons Live et Studio"
)

plot_streams
plot_views
```

**Observations **

D'après les boxplots, on constate que les morceaux live ont tendance à avoir plus de vues sur Youtube que sur Spotify. En effet, les médianes des vues Youtubes sont très similaires, mais les morceaux live ont une plus grande amplitude de vues sur Youtube que sur Spotify.
Cela peut confirmer l'hypothèse selon laquelle les morceaux live sont plus populaires sur Youtube que sur Spotify. Cependant, il est important de noter que le nombre de morceaux live est très faible par rapport au nombre total de morceaux, ce qui peut fausser les résultats. De plus, il est possible que d'autres facteurs influencent le nombre de vues et d'écoutes, tels que la popularité de l'artiste ou la qualité de la vidéo.

***

### Question 5 : Quelle est la distribution des durées des morceaux ? 

Nous voulons observer si les morceaux presents dans le dataset suivent une longueur standard.


**Hypothèses**

D'après une etude en 2019, fait par le media americain Quartz, la durée moyenne d'une chanson est de 3min 30s.


**Traitement des données**

Avant de faire des visualisations, nous devons s'assurer qu'il n'y a pas de valeurs nulls dans la colonne Duration_ms. Apres cela, nous allons changer l'unité de durée, passant de ms en minutes, afin de mieux interpreter les valeurs.
```{r message=FALSE, warning=FALSE}
dataset_question_5 <- dataset %>%
  filter(!is.na(Duration_ms)) %>%
  mutate(Duration_min = (Duration_ms / 1000) / 60)
```

**Visualisation**

Le premier graphe est un boxplot, afin de voir le nombre des outliers presents dans le dataset.
```{r message=FALSE, warning=FALSE}
mean_duration <- mean(dataset_question_5$Duration_min)

ggplot(dataset_question_5, aes(x = "", y = Duration_min)) +
  geom_boxplot() +
  ggtitle("Graphique 1 : Repartition de musiques en fonction de la durée") +
  labs(y = "Durée (en minutes)") +
  theme(axis.text.x = element_blank()) +
  geom_hline(yintercept = mean_duration, color = "red", linetype = "solid", size = 0.5) +
  xlab("") +
  stat_summary(
    aes(x = "", y = Duration_min, label = round(..y.., 1)),
    fun = mean,
    geom = "text",
    vjust = -1,
    color = "red"
  )
```
Sur ce graphe, nous pouvons voir que la durée moyenne d'une chanson est de 3min42, ce qui est tres proche de notre hypothese. Cependant, nous pouvons voir qu'il y a beaucoup d'outliers presents. QUelques-uns d'entre eux sont tres loin de la durée moyenne, ce qui peut impacter la moyenne. Afin de mieux voir la repartition des valeurs, nous pouvons utiliser un histogram. Dans ce histogramme, nous n'allons pas considerer des valeurs au-dessus de 10 minutes.


```{r message=FALSE, warning=FALSE}
dataset_question_5_plot2 <- dataset_question_5 %>% filter(Duration_min < 10)

ggplot(data = dataset_question_5_plot2, aes(x = Duration_min)) +
  geom_histogram(aes(y = ..density..), bins = 50, fill = "#69b3a2", color = "#e9ecef", alpha = 0.9) +
  stat_function(
    fun = dnorm,
    args = list(mean = mean(dataset_question_5_plot2$Duration_min), sd = sd(dataset_question_5_plot2$Duration_min)),
    aes(color = "Densité theorique"),
    size = 1
  ) +
  geom_vline(aes(xintercept = mean(Duration_min)), color = "red", linetype = "dashed", size = 0.5) +
  scale_x_continuous(breaks = seq(0, 20, 1)) +
  ggtitle("Graphique 2 : Repartition de musiques en fonction de la durée") +
  labs(x = "Durée (en minutes)", y = "Fréquence") +
  scale_color_manual(
    name = "Légende",
    values = c("Densité theorique" = "red")
  )
```

Maintenant qu'on a vu la repartition, il serait interessant de voir si les chansons d'une durée entre 3 à 4 minutes ont une tonalité differente de celle des outliers.
```{r message=FALSE, warning=FALSE}
dataset_question5_plot3 <- dataset_question_5 %>%
  filter(Duration_min <= 4) %>%
  filter(Duration_min >= 3) %>%
  count(Key) %>%
  arrange(n)

dataset_question5_plot3$Key <- factor(dataset_question5_plot3$Key, levels = dataset_question5_plot3$Key)

dataset_question5_plot3$Key <- fct_recode(dataset_question5_plot3$Key,
  "Do" = "0",
  "Do / Ré" = "1",
  "Ré" = "2",
  "Ré / Mi" = "3",
  "Mi" = "4",
  "Fa" = "5",
  "Fa / Sol" = "6",
  "Sol" = "7",
  "Sol / La" = "8",
  "La" = "9",
  "La / Si" = "10",
  "Si" = "11"
)

ggplot(dataset_question5_plot3, aes(x = Key, y = n, fill = Key)) +
  geom_bar(width = 0.9, stat = "identity") +
  coord_polar(theta = "y") +
  ylim(c(0, 2000)) +
  ggtitle("Graphique 3 : Repartition de musiques d'une durée entre 3 à 4 minutes en fonction de la tonalité") +
  labs(x = "Tonalité", y = "Frequence", fill = "Tonalité")
```

```{r message=FALSE, warning=FALSE}
dataset_question5_plot4 <- dataset_question_5 %>%
  filter(Duration_min >= 10) %>%
  count(Key) %>%
  arrange(n)

dataset_question5_plot4$Key <- factor(dataset_question5_plot4$Key, levels = dataset_question5_plot4$Key)

dataset_question5_plot4$Key <- fct_recode(dataset_question5_plot4$Key,
  "Do" = "0",
  "Do / Ré" = "1",
  "Ré" = "2",
  "Ré / Mi" = "3",
  "Mi" = "4",
  "Fa" = "5",
  "Fa / Sol" = "6",
  "Sol" = "7",
  "Sol / La" = "8",
  "La" = "9",
  "La / Si" = "10",
  "Si" = "11"
)

ggplot(dataset_question5_plot4, aes(x = Key, y = n, fill = Key)) +
  geom_bar(width = 0.9, stat = "identity") +
  coord_polar(theta = "y") +
  ylim(c(0, 40)) +
  ggtitle("Graphique 4 : Repartition de musiques d'une durée superieur de 20 minutes en fonction de la tonalité") +
  labs(x = "Tonalité", y = "Frequence", fill = "Tonalité")
```
**Observations diverses**

D'après les 4 visualisations ci-dessous, nous avons vu que le dataset present respecte bien la durée moyenne d'une chanson, malgré la presence de certains outliers. Pour aller plus loin, nous avons regarder la tonalité des chansons d'une durée moyenne, comparant a la tonalité des chansons d'une durée superieur à 10 minutes. 

Pour le graphique 3, les tonalités les plus presentes sont Do/Ré, Sol et Do. Pour le graphique 4, les tonalités les plus presentes sont Sol et Mi. Ce qui aurait etait pertinent dans l'analyse, c'est d'avoir une la separation entre les gammes majeurs et mineurs egalement.  

### Question 6 : Les vidéos officielles ont-elles plus de vues que les autres ?

**Hypothèse :**

Les vidéos officielles pourraient avoir plus de vues que les autres

**Traitement des données :**

On ne garde "que" les $19549$ vidéos de Youtube.

```{r message=FALSE, warning=FALSE}
youtube_dataset <- dataset %>%
  filter(!is.na(Views)) %>%
  select(where(is.numeric), Views, official_video) %>%
  na.omit()
```

**Visualisations :**

On affiche les vues selon si la vidéo est officielle ou non.

```{r message=FALSE, warning=FALSE}
ggplot(youtube_dataset, aes(y=Views, x=official_video)) + geom_boxplot() +
  scale_y_log10(labels=label_number(scale_cut=cut_short_scale())) +
  scale_x_discrete(labels=c("Non officielle", "Officielle")) +
  labs(x = "Type de vidéo", y = "Nombre de vues") +
  ggtitle("Graphique 1 : Répartition du nombre de vues selon si la vidéo est officielle")

ggplot(youtube_dataset, aes(Views, fill=official_video, color=official_video)) +
  geom_density(alpha=0.1) +
  scale_x_log10(labels=label_number(scale_cut=cut_short_scale())) +
  scale_color_discrete(name="Type de vidéo", labels=c("Non officielle", "Officielle")) +
  scale_fill_discrete(guide="none") +
  ggtitle("Graphique 2 : Densité du nombre de vues selon si la vidéo est officielle") +
  labs(x = "Nombre de vues", y = "Densité") +
  theme(axis.text.y = element_blank())
```

Afin de bien comprendre ces graphiques, on calcule le nombre de vidéos officielles et non officielles :

| Vidéos officielles | Vidéos non officielles |
| - | - |
| 15260 | 4289 |

Les vidéos officielles font donc plus de vues que les vidéos non officielles. On peut noter cependant que nous avons plus de vidéos officielles que de vidéos non officielles dans le dataset. On peut supposer que les artistes connus publient tous leurs musiques dans des musiques "officielles" et que leurs republications se font supprimer par Youtube.

### Question 7 :  Quelles sont les variables qui influencent les performances sur Youtube et Spotify ?

**Hypothèse :**
Certaines features, comme l'énergie ou le tempo sont peut être corrélées avec les performances. Pour rappel, les indicateurs de performance dépendent de la plateforme :

- nombre de vues, likes et commentaires pour Youtube
- nombre de streams pour Spotify

**Traitement des données :**
Nous souhaitons réaliser une heatmap de la corrélation entre les features et les performances des musiques. Puisque la performance ne se mesure pas de la même façon sur les deux plateformes, nous allons faire deux heatmaps et donc séparer le dataset en deux : les musiques présentes sur Spotify et les musiques présentes sur Youtube. \
Afin de calculer correctement la corrélation entre les différentes features et les indices de performance, on enlève également toutes les musiques dont au moins une feature est absente de notre dataset.
```{r message=FALSE, warning=FALSE}
# Commençons par Spotify
spotify_dataset <- dataset %>%
  filter(!is.na(Stream)) %>% # On retire les musiques qui n'ont pas de nombre de streams
  select(where(is.numeric), -...1, -Likes, -Views, -Comments) %>% # On retire les colonnes inutiles
  na.omit()
# On retire la ligne si elle contient des valeurs non numériques
spotify_dataset %>%
  nrow() %>%
  print()
# On affiche le nombre de musiques présentes sur Spotify
# Faisons la même chose pour Youtube
youtube_dataset <- dataset %>%
  filter(!is.na(Views)) %>%
  select(where(is.numeric), -...1, -Stream) %>%
  na.omit()
youtube_dataset %>%
  nrow() %>%
  print()
```

On va donc visualiser les données de $20140$ musiques pour Spotify et $20099$ musiques pour Youtube.

**Visualisations :**
Faisons d'abord une heatmap pour montrer la corrélation entre les différentes features et la performance des musiques sur Spotify :
```{r message=FALSE, warning=FALSE}
correlation <- spotify_dataset %>%
  cor(method = "pearson") %>% # Dressons une matrice de corrélation en utilisant les valeurs
  as.table() %>% # On transforme la matrice en un tableau contenant la ligne, la colonne et la valeur
  as.data.frame() %>% # On recupère le tableau dans un dataframe
  mutate(value = abs(Freq))
# On ne conserve que la valeur absolue de la corrélation
correlation %>%
  ggplot(aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_viridis_c(option = "inferno") +
  theme(
    axis.title = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.4, hjust = 0.9),
    plot.title = element_text(size = 12)
  ) +
  ggtitle("Corrélation entre les différentes features et les performances sur Spotify") +
  labs(fill = "Indice de\ncorrélation")
```

On constate déjà que la performance sur Spotify *(Stream)* est très peu corrélée avec les différentes features des musiques. On voit que la corrélation la plus élevée reste très faible (~15%) et concerne l'intensité sonore, l'acoustique et l'instrumentalité.

Afin d'y voir plus clair, nous allons réaliser un *BarPlot* des features pour afficher leur corrélation avec le nombre de streams :

```{r message=FALSE, warning=FALSE}
columns <- c("Stream", "Views", "Likes", "Comments")
correlation %>%
  filter(Var1 %in% columns & !Var2 %in% columns) %>%
  ggplot(aes(x = Var2, y = value, fill = Var1)) +
  geom_bar(position = "dodge", stat = "identity") +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.4, hjust = 0.9),
    plot.title = element_text(size = 12)
  ) +
  labs(x = "Feature", y = "Corrélation", fill = "Performance") +
  ggtitle("Importance des features dans la performance de la musique sur Spotify")
```

On peut désormais classer plus facilement les différentes features en ordre d'importance : *Loudness* puis *Acousticness* puis *Instrumentalness*. \
Cependant, ces valeurs restent faibles (environ 10% de corrélation) : il n'y a donc pas de recette miracle pour percer sur Spotify !

Regardons maintenant ce qu'il en est sur Youtube. On souhaite regarder ici la corrélation entre les différentes features et le nombre de vues, de likes et de commentaires :

```{r message=FALSE, warning=FALSE}
correlation <- youtube_dataset %>%
  cor(method = "pearson") %>%
  as.table() %>%
  as.data.frame() %>%
  mutate(value = abs(Freq))
correlation %>%
  ggplot(aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_viridis_c(option = "inferno") +
  theme(
    axis.title = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.4, hjust = 0.9),
    plot.title = element_text(size = 12)
  ) +
  ggtitle("Corrélation entre les différentes features et les performances sur Youtube") +
  labs(fill = "Indice de\ncorrélation")
```

On remarque deux choses :

- il va falloir réfléchir à notre indicateur de succès puisque les likes et les vues sont plus corrélées entre elles qu'avec le nombre de commentaires
- les features qui semblent les plus impactantes sur la performance d'une musique sont, comme sur Spotify, l'intensité sonore, l'acoustique, l'instrumentalité avec le côté dansant de la musique.

De la même façon que précédemment, on affiche la corrélation entre les différentes features et nos indicateurs de performance :

```{r message=FALSE, warning=FALSE}
columns <- c("Stream", "Views", "Likes", "Comments")
correlation %>%
  filter(Var1 %in% columns & !Var2 %in% columns) %>%
  ggplot(aes(x = Var2, y = value, fill = Var1)) +
  geom_bar(position = "dodge", stat = "identity") +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.4, hjust = 0.9),
    plot.title = element_text(size = 12)
  ) +
  labs(x = "Feature", y = "Corrélation", fill = "Performance") +
  ggtitle("Importance des features dans la performance de la musique sur Youtube")
```

Le côté dansant de la musique arrive en $2^e$ position, et semble donc plus important que sur Spotify. Cela dit, cela reste à nuancer puisque la corrélation reste très faible. Ainsi, comme sur Spotify, nous n'avons pas encore trouvé la recette du succès sur Youtube.

**Observations diverses :**
Nous avons constaté différentes choses intéressantes dans ces visualisations:

* les critères de performance sur Youtube ne sont pas corrélés entre eux de manière égale
* certaines features semblent corrélées entre elles (par exemple energy/loudness, energy/acousticness, acousticness/loudness)

***

### Question 9 : Quelle est la tonalité la plus fréquente dans les chansons du dataset ?

**Hypothèse**

Certaines tonalités sont peut être plus présentes que d'autres dans le dataset.

**Traitement des données**

Afin de pouvoir utiliser les données correctement et d'afficher les résultats de manière lisible, on va transformer les codes des différentes tonalités en leur valeur (ex. 0 = Do). Par la même occasion, on crée une catégorie pour les musiques dont la tonalité n'a pas pu être déterminée. On retire également les colonnes inutiles.

```{r message=FALSE, warning=FALSE}
keys <- dataset %>%
  select(Key, Views, Stream, Likes, Comments) %>%
  mutate(Key = replace_na(Key, 12))
note_labels <- c(
  "Do",
  "Do♯/Ré♭",
  "Ré",
  "Ré♯/Mi♭",
  "Mi",
  "Fa",
  "Fa♯/Sol♭",
  "Sol",
  "Sol♯/La♭",
  "La",
  "La♯/Si♭",
  "Si",
  "Tonalité inconnue"
)
keys$Key <- factor(keys$Key, levels = 0:12, labels = note_labels)
keys_only <- keys %>% select(Key)
```

**Visualisations**

Nous allons compter le nombre de musiques pour chaque tonalité, et afficher les résultats à l'aide d'un barchart.

```{r message=FALSE, warning=FALSE}
keys_only %>% ggplot(aes(x = Key)) +
  geom_bar(fill = theme, color = "white", width = 1) +
  labs(
    title = "Distribution des tonalités",
    x = "Tonalité",
    y = "Nombre de musiques"
  ) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.4, hjust = 0.9),
    plot.title = element_text(size = 12)
  )
```

On constate que certaines tonalités sont légèrement plus présentes que les autres sur les plateformes Youtube and Spotify, comme le Do, Sol, Do♯/Ré♭, Ré et La.

On remarque également qu'il y a nettement moins de musiques avec la tonalité Ré♯/Mi♭. On va tenter de voir s'il existe des corrélations entre le succès d'une musique et sa tonalité, ce qui pourrait expliquer le faible nombre de musiques en Ré♯/Mi♭.

```{r message=FALSE, warning=FALSE, fig.height=3}
keys %>%
  filter(Key != note_labels[13]) %>%
  group_by(Key) %>%
  summarise(
    Streams = mean(Stream, na.rm = TRUE), Likes = mean(Likes, na.rm = TRUE),
    Comments = mean(Comments, na.rm = TRUE), Views = mean(Views, na.rm = TRUE)
  ) %>%
  mutate(across(
    where(is.numeric),
    ~ (. - min(., na.rm = TRUE)) / (max(., na.rm = TRUE) - min(., na.rm = TRUE))
  )) %>%
  pivot_longer(
    cols = c(Streams, Likes, Comments, Views), names_to = "Stat", values_to = "Value"
  ) %>%
  ggplot(aes(x = Key, y = Stat, fill = Value)) +
  geom_tile() +
  scale_fill_viridis_c(option = "inferno") +
  theme(
    axis.title = element_blank(),
    axis.text.x = element_text(angle = 90, vjust = 0.4, hjust = 0.9),
    plot.title = element_text(size = 12)
  ) +
  ggtitle("Succès moyen de la musique selon la tonalité") +
  labs(fill = "Succès\n(normalisé)")
```

Afin de mieux comprendre l'échelle utilisée dans ce graphique, on a calculé la différence entre la valeur la plus foncée et la valeur la plus claire :

| Critère | Views | Streams | Likes | Comments |
| - | - | - | - | - | - |
| Différence maximale | 35803828 | 223427.8 | 19711.53 | 28328929 |
| Part de la valeur maximale | 0.23 | 0.29 | 0.49 | 0.26 |

Les différences présentes dans ce graphique sont donc significatives, et on peut constater que les musiques en Si, Fa♯/Sol♭ sont les musiques avec le plus gros succès en moyenne sur Youtube là où les musiques en Do♯/Ré♭ sont les musiques qui ont le plus gros succès en moyenne sur Spotify.

La réponse à la question soulevée par le graphique précédent, à savoir *est-ce que les musiques en Ré♯/Mi♭ sont les moins présentes des plateformes de streaming à cause de leur manque de popularité*, n'est pas tout à fait claire.

En effet, les musiques en La et Sol ont des performances moyennes inférieures mais sont plus nombreuses sur Youtube et Spotify.

***
### Question 10 : Quelle est la relation entre la présence d’un contenu sous licence et le nombre de vues ?

**Hypothèse **

On peut supposer que les musiques sous licence ont plus de vues que les musiques sans licence. En effet, les musiques sous licence sont souvent des musiques populaires, qui ont été diffusées à la radio ou à la télévision, et qui ont donc plus de chances d'être vues par un plus grand nombre de personnes.

**Visualisation **

Nous allons créer un graphique qui compare le nombre de vues des musiques sous licence et des musiques sans licence. Pour cela, nous allons utiliser un boxplot.

```{r message=FALSE, warning=FALSE}
plot_boxplot(
  dataset %>% select(Licensed, Views) %>% na.omit(), 
  "Licensed", "Views", 
  "Type de chanson","Nombre de vues (log)",
  "Comparaison des vues des musiques"," sous licence et sans licence"
) +
  scale_x_discrete(labels = c("TRUE" = "Sous licence", "FALSE" = "Non licenciée"))
```

***
### Question 11 : Est-ce qu'une tonalité a un effet sur le type de chanson ? 
Dans cette question, nous allons examiner les differentes caractéristiques des musiques pour chaque tonalité. Le but est de voir s'il existe une variation des différentes caractéristiques en fonction de la tonalité globale de la chanson.

**Hypothèses**

Avant de faire des visualisations, nous pouvons supposer que la tonalité a un effet sur certaines caractéristiques, pas toutes. Par exemple, les tonalités majeures sont plus chaleureuses et festives, tandis que les tonalités mineures donnent un effet plutôt nostaligique. Ainsi, nous pouvons supposer que les chansons dans les tonalités majeures vont avoir les features, tel que "danceability" et "energy" plus importantes que les chansons écrites dans des tonalités mineures.


**Traitement des données**

Le dataset, tel qu'il est actuellement, n'est pas adapté à faire une seule visualisation représentant toutes les caractéristiques en fonction des tonalités. Voici les deux traitement essentiels à faire, avant de passer à l'étape de visualisation : 


- Calcul des moyennes pour chaque feature utilisée : afin de pouvoir afficher les caractéristiques des chansons en fonction de la tonalité en tant qu'un bar chart, il faut les grouper par tonalité et calculer la moyenne.
- Pivoter le dataset : Afin de colorier les barres par des couleurs différentes en fonction des caractéristiques, il faut pivoter le dataset en utilisant la fonction pivot_longer.
```{r message=FALSE, warning=FALSE}
avg_danceability <- dataset %>%
  group_by(Key) %>%
  summarise(danceability = mean(Danceability, na.rm = TRUE))

avg_Energy <- dataset %>%
  group_by(Key) %>%
  summarise(energy = mean(Energy, na.rm = TRUE))

avg_Loudness <- dataset %>%
  group_by(Key) %>%
  summarise(loudness = mean(Loudness, na.rm = TRUE))

avg_Speechiness <- dataset %>%
  group_by(Key) %>%
  summarise(speechiness = mean(Speechiness, na.rm = TRUE))

avg_Acousticness <- dataset %>%
  group_by(Key) %>%
  summarise(acousticness = mean(Acousticness, na.rm = TRUE))

avg_Instrumentalness <- dataset %>%
  group_by(Key) %>%
  summarise(instrumentalness = mean(Instrumentalness, na.rm = TRUE))

avg_Liveness <- dataset %>%
  group_by(Key) %>%
  summarise(liveness = mean(Liveness, na.rm = TRUE))

avg_Valence <- dataset %>%
  group_by(Key) %>%
  summarise(valence = mean(Valence, na.rm = TRUE))

avg_Tempo <- dataset %>%
  group_by(Key) %>%
  summarise(tempo = mean(Tempo, na.rm = TRUE))

graphe_11_a <- data.frame(
  avg_Tempo[1], avg_Valence[2], avg_Liveness[2], avg_Instrumentalness[2],
  avg_Acousticness[2], avg_Speechiness[2], avg_Energy[2], avg_danceability[2]
)
graphe_11_a <- graphe_11_a |>
  pivot_longer(
    cols = liveness:danceability,
    names_to = "Type",
    values_to = "Value"
  )

graphe_11_b <- data.frame(avg_Tempo[1], avg_Tempo[2])

graphe_11_c <- data.frame(avg_Tempo[1], avg_Loudness[2])
```

**Visualisation**

Dans le plan d'analyse initial, nous avons proposé de creer un barplot par tonalité. Cependant, cette méthode ne sera pas pertinente pour trouver une corrélation. Ainsi, un group bar chart est plus adapté. La plupart des caractéristiques sont des scores allant de 0 à 1, sauf le Tempo (entre 0 et 125BPM) et la Loudness (entre -9 et 0 dB). Ainsi, pour garder une bonne lisibilité, nous avons décidé de faire 3 graphes : 1 grouped bar chart avec les scores, 1 bar chart avec le Tempo, et 1 bar chart avec la Loudness.


Affichage du graphique 1
```{r message=FALSE, warning=FALSE}
graphe_11_a <- graphe_11_a %>% filter(!is.na(Key))

graphe_11_1 <- data.frame(
  row.names = c("Do", "Do / Ré", "Ré", "Ré / Mi", "Mi", "Fa", "Fa / Sol", "Sol", "Sol / La", "La", "La / Si", "Si", "NaN"),
  valence = avg_Valence[2],
  liveness = avg_Liveness[2],
  instrumentalness = avg_Instrumentalness[2],
  acousticness = avg_Acousticness[2],
  speechiness = avg_Speechiness[2],
  energy = avg_Energy[2],
  danceability = avg_danceability[2]
)

max_min <- data.frame(
  valence = c(1, 0), liveness = c(1, 0), instrumentalness = c(1, 0),
  acousticness = c(1, 0), speechiness = c(1, 0), energy = c(1, 0),
  danceability = c(1, 0)
)
rownames(max_min) <- c("Max", "Min")

graphe_11_1 <- rbind(max_min, graphe_11_1)

do_data <- graphe_11_1[c("Max", "Min", "Do"), ]

create_beautiful_radarchart <- function(data, color = "#00AFBB",
                                        vlabels = colnames(data), vlcex = 0.7,
                                        caxislabels = NULL, title = NULL, ...) {
  radarchart(
    data,
    axistype = 1,
    # Customize the polygon
    pcol = color, pfcol = scales::alpha(color, 0.5), plwd = 2, plty = 1,
    # Customize the grid
    cglcol = "grey", cglty = 1, cglwd = 0.8,
    # Customize the axis
    axislabcol = "grey",
    # Variable labels
    vlcex = vlcex, vlabels = vlabels,
    caxislabels = caxislabels, title = title, ...
  )
}

# Définir les couleurs (13 couleurs différentes)
colors <- c(
  "#00AFBB", "#E7B800", "#FC4E07", "#7CAE00", "#C77CFF",
  "#00BFC4", "#F8766D", "#A3A500", "#FF61C3", "#619CFF",
  "#FFB000", "#00C19F"
)

# Titres des graphiques
titles <- c("Do", "Do / Ré", "Ré", "Ré / Mi", "Mi", "Fa", "Fa / Sol", "Sol", "Sol / La", "La", "La / Si", "Si")

# Réduire les marges et définir une grille de 3 lignes × 5 colonnes
# (ça affiche 15 emplacements, donc les 13 étudiants auront de la place)
op <- par(mar = c(1, 1, 2, 1))
par(mfrow = c(3, 5))

# Créer les radars pour chaque étudiant
for (i in 1:12) {
  create_beautiful_radarchart(
    data = graphe_11_1[c(1, 2, i + 2), ],
    caxislabels = c(0, 2.5, 5, 7.5, 10),
    color = colors[i],
    title = titles[i]
  )
}

# Réinitialiser les paramètres graphiques
par(op)
```


Affichage du graphique 2
```{r message=FALSE, warning=FALSE}
ggplot(dataset, aes(x = factor(Key), y = Tempo, color = factor(Key))) +
  geom_violin(trim = FALSE) +
  theme_minimal() +
  labs(x = "Tonalité", y = "Tempo") +
  ggtitle("Graphique 2 : Distribution du Tempo par Tonalité")
```


Affichage du graphique 3
```{r message=FALSE, warning=FALSE}
ggplot(dataset, aes(x = factor(Key), y = Loudness, color = factor(Key))) +
  geom_violin(trim = FALSE) +
  theme_minimal() +
  labs(x = "Tonalité", y = "Loudness") +
  ggtitle("Graphique 3 : Distribution du Loudness par Tonalité")
```

**Observations diverses**

D'après les 3 visualisations ci-dessus, nous pouvons constater que la tonalité n'a pas d'effet sur les caractéristiques musicales.

La question a été répondue, mais cette réponse n'est pas la même que dans les hypothèses posées ci-dessus. Ce qui peut être envisagé, c'est de vérifier comment les scores ont été calculés par les algorithmes de Spotify et de YouTube.

***

### Question 13 : Quel artiste est le plus populaire au moment du 7 février 2023 ?  
Nous allons analyser cela selon :
- le nombre de vues sur YouTube
- le nombre d'écoutes sur Spotify
- une moyenne combinée des deux plateformes

**Hypothèse :**
On peut imaginer que certains artistes sont beaucoup plus populaires sur une plateforme que sur l’autre, selon le public visé.

**Traitement des données :**
Le datasetset contient 2079 artistes uniques, il est donc préférable d'afficher uniquement les **50 artistes les plus populaires** pour garder des graphiques lisibles.

On constate aussi que certains individus n'ont pas d'url Youtube, ce qui pourrait compromettre la comparaison vues/streams
```{r message=FALSE, warning=FALSE}
# nb total de musiques
total_musiques <- nrow(dataset)
# nb d'individus sans vidéos youtube
total_sans_ytb <- nrow(dataset[dataset$Url_youtube == "", ])
# % d'individus sans vidéos youtube
pourcentage_sans_ytb <- (total_sans_ytb / total_musiques) * 100

cat("Nombre total de musiques :", total_musiques, "\n")
cat("Nombre de musiques sans vidéos YouTube :", total_sans_ytb, "\n")
cat("Pourcentage de musiques sans vidéos YouTube :", round(pourcentage_sans_ytb, 2), "%\n")
```
Étant donné que seulement $2,27%$ des musiques ne disposent pas de données YouTube, nous avons décidé de les supprimer sans risque d'altérer l'analyse globale.
```{r message=FALSE, warning=FALSE}
# Suppression des musiques sans URL YouTube
dataset <- dataset[dataset$Url_youtube != "", ]
total_musiques <- nrow(dataset)
cat("Nombre total de musiques après suppression :", total_musiques, "\n")
```
**Visualisations :**

```{r message=FALSE, warning=FALSE, fig.height=10, fig.width=8, dpi=130}
# Top 50 artistes selon les vues YouTube
top_views <- dataset %>%
  group_by(Artist) %>%
  summarise(Total_Views = sum(Views, na.rm = TRUE)) %>%
  arrange(desc(Total_Views)) %>%
  slice_head(n = 50) %>%
  mutate(Rank_Youtube = row_number())

# Graphique
ggplot(top_views, aes(
  x = Total_Views / 1e6,
  y = reorder(paste(Rank_Youtube, Artist, sep = " - "), Total_Views)
)) +
  geom_point(size = 3) +
  geom_text(aes(label = round(Total_Views / 1e6, 1)), hjust = -0.5, size = 2.5) +
  labs(
    title = "Top 50 artistes - Vues YouTube",
    x = "Nombre de vues (en millions)",
    y = "Artiste"
  ) +
  scale_x_continuous(labels = comma, expand = expansion(mult = c(0, 0.15))) +
  theme_minimal() +
  theme(
    plot.margin = margin(10, 40, 10, 10), # marges plus larges à droite
    axis.text.y = element_text(size = 6) # textes des artistes plus petits pour aérer
  )
```

```{r message=FALSE, warning=FALSE, fig.height=10, fig.width=8, dpi=130}
# Top 50 artistes selon les streams Spotify
top_streams <- dataset %>%
  group_by(Artist) %>%
  summarise(Total_Streams = sum(Stream, na.rm = TRUE)) %>%
  arrange(desc(Total_Streams)) %>%
  slice_head(n = 50) %>%
  mutate(Rank_Spotify = row_number())

# Graphique
ggplot(top_streams, aes(
  x = Total_Streams / 1e6,
  y = reorder(paste(Rank_Spotify, Artist, sep = " - "), Total_Streams)
)) +
  geom_point(size = 3) +
  geom_text(aes(label = round(Total_Streams / 1e6, 1)), hjust = -0.5, size = 2.5) +
  labs(
    title = "Top 50 artistes - Écoutes Spotify",
    x = "Nombre d'écoutes (en millions)",
    y = "Artiste"
  ) +
  scale_x_continuous(labels = comma, expand = expansion(mult = c(0, 0.15))) +
  theme_minimal() +
  theme(
    plot.margin = margin(10, 40, 10, 10), # marges plus larges à droite
    axis.text.y = element_text(size = 6) # textes des artistes plus petits pour aérer
  )
```
On constate que certains artistes affichent des disparités entre vues et streams. Par exemple, Post Malone est premier en nombre de streams Spotify mais se classe seulement $37^e$ en vues YouTube, tandis que CoComelon est deuxième en vues YouTube sans apparaître dans le top Spotify.
Cela confirme l'idée que la plateforme impacte la visibilité et la consommation de certains artistes.
```{r message=FALSE, warning=FALSE, fig.height=10, fig.width=8, dpi=130}
# Top 50 artistes combiné (Vues + Streams)
top_combined <- dataset %>%
  group_by(Artist) %>%
  summarise(
    Total_Views = sum(Views, na.rm = TRUE),
    Total_Streams = sum(Stream, na.rm = TRUE)
  ) %>%
  mutate(Score = Total_Views + Total_Streams) %>%
  arrange(desc(Score)) %>%
  slice_head(n = 50) %>%
  mutate(Rank_Combined = row_number())

# Graphique
ggplot(top_combined, aes(
  x = Score / 1e6,
  y = reorder(paste(Rank_Combined, Artist, sep = " - "), Score)
)) +
  geom_point(size = 3) +
  geom_text(aes(label = round(Score / 1e6, 1)), hjust = -0.5, size = 2.5) +
  labs(
    title = "Top 50 artistes - Score combiné (Vues + Écoutes)",
    x = "Score combiné (en millions)",
    y = "Artiste"
  ) +
  scale_x_continuous(labels = comma, expand = expansion(mult = c(0, 0.15))) +
  theme_minimal() +
  theme(
    plot.margin = margin(10, 40, 10, 10), # marges plus larges à droite
    axis.text.y = element_text(size = 6) # textes des artistes plus petits pour aérer
  )
```
On obtient une vision plus complète de la popularité des artistes.
Certains artistes dominent les deux plateformes de manière équilibrée, tandis que d'autres sont clairement plus forts sur une seule plateforme.

Au sommet du classement on trouve Ed Sheeran avec presque 30 milliards d'interactions, en tête sur les deux plateformes individuellement.
Des stars internationales remplissent le sommet du top : Justin Bieber, Coldplay, Post Malone Dua Lipa ...

**Observations diverses : **

- Katy Perry ($9^e$ combiné) est beaucoup plus forte sur YouTube que sur Spotify (typé vidéo/Youtube).
- Post Malone ($4^e$ combiné) a plus du double de streams Spotify que de vues YouTube (typé audio/Spotify).
- Luis Fonsi et Daddy Yankee : leur classement est boosté par d'énormes succès vidéo (ex: Despacito) mais leur streaming audio pur est plus faible.
- CoComelon (contenu enfant) : extrêmement populaire sur YouTube, beaucoup moins sur Spotify (presque anecdotique en streaming pur).
- Certains artistes comme Coldplay, Imagine Dragons, Bruno Mars performent de façon équilibrée entre plateformes.

La liste montre une très forte dominance de la pop et du hip-hop/RnB mais aussi de quelques artistes de musique latine.

Nous allons analyser les artistes qui figurent uniquement dans l’un des deux classements, cette comparaison permettra de mettre en évidence les artistes qui bénéficient d'une popularité très marquée sur une seule plateforme. (On met le rang)

```{r comparaison_top50, message=FALSE, warning=FALSE, fig.height=6, fig.width=14, dpi=300}
# Top 50 artistes par vues YouTube
top_views <- dataset %>%
  group_by(Artist) %>%
  summarise(Total_Views = sum(Views, na.rm = TRUE)) %>%
  arrange(desc(Total_Views)) %>%
  slice_head(n = 50)

# Top 50 artistes par streams Spotify
top_streams <- dataset %>%
  group_by(Artist) %>%
  summarise(Total_Streams = sum(Stream, na.rm = TRUE)) %>%
  arrange(desc(Total_Streams)) %>%
  slice_head(n = 50)

# Artistes dans le top Spotify mais PAS dans le top YouTube
spotify_only <- setdiff(top_streams$Artist, top_views$Artist)

# Artistes dans le top YouTube mais PAS dans le top Spotify
youtube_only <- setdiff(top_views$Artist, top_streams$Artist)

# Données pour Spotify only
spotify_only_dataset <- dataset %>%
  filter(Artist %in% spotify_only) %>%
  group_by(Artist) %>%
  summarise(Total_Views = sum(Views, na.rm = TRUE)) %>%
  arrange(desc(Total_Views))

# Données pour YouTube only
youtube_only_dataset <- dataset %>%
  filter(Artist %in% youtube_only) %>%
  group_by(Artist) %>%
  summarise(Total_Streams = sum(Stream, na.rm = TRUE)) %>%
  arrange(desc(Total_Streams))

# Premier graphique : Spotify only (vues YouTube)
ggplot(spotify_only_dataset, aes(Total_Views / 1e6, reorder(Artist, Total_Views))) +
  geom_point(size = 3, color = "steelblue") +
  geom_text(aes(label = round(Total_Views / 1e6, 1)), hjust = -0.5, size = 2.5) +
  labs(
    title = "Artistes Top 50 Spotify (hors Top 50 YouTube)",
    x = "Nombre de vues YouTube (en millions)",
    y = "Artiste"
  ) +
  scale_x_continuous(labels = comma, expand = expansion(mult = c(0, 0.15))) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 6),
    plot.margin = margin(10, 40, 10, 10)
  )

# Deuxième graphique : YouTube only (streams Spotify)
ggplot(youtube_only_dataset, aes(Total_Streams / 1e6, reorder(Artist, Total_Streams))) +
  geom_point(size = 3, color = "darkorange") +
  geom_text(aes(label = round(Total_Streams / 1e6, 1)), hjust = -0.5, size = 2.5) +
  labs(
    title = "Artistes Top 50 YouTube (hors Top 50 Spotify)",
    x = "Nombre d'écoutes Spotify (en millions)",
    y = "Artiste"
  ) +
  scale_x_continuous(labels = comma, expand = expansion(mult = c(0, 0.15))) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 6),
    plot.margin = margin(10, 40, 10, 10)
  )
```
On voit en bas de chaque classement les artistes qui ont de grosses disparités d'interaction entre les plateformes.
Parmi les artistes du top stream, on voit qu'Olivia Rodrigo ou Doja Cat ont beaucoup moins d'interactions sur YouTube.
Au contraire, on voit que des artistes ayant un fort succès sur YouTube comme CoComelon ou PSY ont des performances bien moindres sur Spotify.

### Question 14 : Peut-on visualiser des clusters de chansons selon leurs caractéristiques avec la t-SNE ?

...

**Hypothèse :**
...

**Traitement des données :**
...
```{r tsne_streams, message=FALSE, warning=FALSE, echo=FALSE}
library(Rtsne)
library(plotly)
library(dplyr)

# Sélection des features numériques pertinentes
tsne_data <- dataset %>%
  select(Duration_ms, Tempo, Valence, Liveness, Instrumentalness, Acousticness, Speechiness, Loudness, Key, Energy, Danceability, Stream) %>%
  na.omit()

# Retirer les doublons sur les colonnes utilisées pour le t-SNE (sans Stream)
tsne_data_nostream <- tsne_data %>%
  select(-Stream) %>%
  distinct()
# On garde l’index pour retrouver les infos plus tard
tsne_data <- tsne_data[as.numeric(rownames(tsne_data_nostream)), ]

set.seed(42)
if (nrow(tsne_data_nostream) > 2000) {
  idx <- sample(nrow(tsne_data_nostream), 2000)
  tsne_data_nostream <- tsne_data_nostream[idx, ]
  tsne_data <- tsne_data[idx, ]
}

# t-SNE en 2D
tsne_result <- Rtsne(as.matrix(tsne_data_nostream), dims = 2, perplexity = 30, verbose = TRUE, max_iter = 500)
tsne_df <- as.data.frame(tsne_result$Y)
colnames(tsne_df) <- c("Dim1", "Dim2")

# Ajout des infos pour le survol et la couleur
tsne_df$Title <- dataset$Track[as.numeric(rownames(tsne_data))]
tsne_df$Artist <- dataset$Artist[as.numeric(rownames(tsne_data))]
tsne_df$Stream <- tsne_data$Stream

# Tooltip personnalisé
tsne_df$hover <- paste0(
  "<b>", tsne_df$Title, "</b><br>",
  "Artiste : ", tsne_df$Artist, "<br>",
  "Streams Spotify : ", format(tsne_df$Stream, big.mark = " ")
)
```
**Visualisations :**

```{r tsne, echo=FALSE}
plot_ly(
  tsne_df,
  x = ~Dim1, y = ~Dim2,
  color = ~Stream, colors = "viridis", # other colors can be
  type = "scatter", mode = "markers",
  marker = list(size = 6, opacity = 0.7),
  text = ~hover,
  hoverinfo = "text"
) %>%
  layout(title = "Projection t-SNE 2D des chansons (couleur = nombre de streams Spotify)")
```

```{r pca, echo=FALSE}
# PCA
pca_result <- prcomp(tsne_data_nostream, scale. = TRUE)
pca_df <- as.data.frame(pca_result$x[, 1:2])
colnames(pca_df) <- c("PC1", "PC2")

# Ajout des infos pour le survol et la couleur
pca_df$Title <- dataset$Track[as.numeric(rownames(tsne_data))]
pca_df$Artist <- dataset$Artist[as.numeric(rownames(tsne_data))]
pca_df$Stream <- tsne_data$Stream

# Tooltip personnalisé
pca_df$hover <- paste0(
  "<b>", pca_df$Title, "</b><br>",
  "Artiste : ", pca_df$Artist, "<br>",
  "Streams Spotify : ", format(pca_df$Stream, big.mark = " ")
)

# Visualisation
plot_ly(
  pca_df,
  x = ~PC1, y = ~PC2,
  color = ~Stream, colors = "viridis",
  type = "scatter", mode = "markers",
  marker = list(size = 6, opacity = 0.7),
  text = ~hover,
  hoverinfo = "text"
) %>%
  layout(title = "Projection PCA 2D des chansons (couleur = nombre de streams Spotify)")
```

```{r umap, echo=FALSE}
library(umap)

# Configuration UMAP
umap_config <- umap.defaults
umap_config$n_neighbors <- 15
umap_config$min_dist <- 0.1
umap_config$random_state <- 42

# UMAP sur les données numériques
umap_result <- umap(as.matrix(tsne_data_nostream), config = umap_config)
umap_df <- as.data.frame(umap_result$layout)
colnames(umap_df) <- c("UMAP1", "UMAP2")

# Ajout des infos
umap_df$Title <- dataset$Track[as.numeric(rownames(tsne_data))]
umap_df$Artist <- dataset$Artist[as.numeric(rownames(tsne_data))]
umap_df$Stream <- tsne_data$Stream

# Tooltip personnalisé
umap_df$hover <- paste0(
  "<b>", umap_df$Title, "</b><br>",
  "Artiste : ", umap_df$Artist, "<br>",
  "Streams Spotify : ", format(umap_df$Stream, big.mark = " ")
)

# Visualisation avec plotly
plot_ly(
  umap_df,
  x = ~UMAP1, y = ~UMAP2,
  color = ~Stream, colors = "viridis",
  type = "scatter", mode = "markers",
  marker = list(size = 6, opacity = 0.7),
  text = ~hover,
  hoverinfo = "text"
) %>%
  layout(title = "Projection UMAP 2D des chansons (couleur = nombre de streams Spotify)")
```